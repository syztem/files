<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;700&display=swap');

        :root {
            --background-color: #1c082a;
            --background-glow-1: rgba(74, 20, 140, 0.4);
            --background-glow-2: rgba(171, 71, 188, 0.3);
            --primary-neon: #ff00ff;
            --secondary-neon: #00ffff;
            --tertiary-neon: #f7ff00;
            --peg-color: #4a148c;
            --peg-glow: #e040fb;
            --peg-hit-glow: #ffffff;
            --ball-color: var(--tertiary-neon);
            --ball-gradient: radial-gradient(circle, #ffffae, var(--tertiary-neon));
            --divider-color: #1c082a;
            --bucket-text-color: #39ff14; 
            --button-bg: var(--primary-neon);
            --button-text: #1a0a2a;
            --score-color: var(--tertiary-neon);
            --particle-color: var(--primary-neon);
            --score-popup-color: var(--tertiary-neon);
        }

        body {
            background-color: var(--background-color);
            color: var(--primary-neon);
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            overflow: hidden;
            text-shadow: 0 0 7px var(--primary-neon);
            position: relative;
        }

        body::before, body::after {
            content: '';
            position: absolute;
            inset: 0;
            z-index: -1;
            pointer-events: none;
        }

        body::before {
            background:
                radial-gradient(circle at 20% 30%, var(--background-glow-1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, var(--background-glow-2) 0%, transparent 50%);
            animation: backgroundGlow 25s ease-in-out infinite alternate;
        }

        body::after {
             background:
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><path d="M0 0 L40 0 M0 0 L0 40" stroke="%23ff00ff" stroke-width="0.3" opacity="0.08" /></svg>'),
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
             background-size: 20px 20px, 5px 5px, 5px 5px;
             animation: backgroundSubtleMove 40s linear infinite;
        }


        @keyframes backgroundGlow {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }

         @keyframes backgroundSubtleMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 80px 80px, 5px 5px, 5px 5px; }
        }


        #ui-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        #drop-button {
            background: linear-gradient(145deg, var(--primary-neon), #c000c0);
            color: var(--button-text);
            border: 2px solid var(--primary-neon);
            padding: 13px 32px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2.5px;
            margin-bottom: 15px;
            border-radius: 6px;
            box-shadow: 0 0 12px var(--button-bg), 0 0 25px var(--button-bg), inset 0 0 5px rgba(255,255,255,0.5);
            transition: all 0.25s ease;
        }

        #drop-button:hover:not(:disabled) {
            box-shadow: 0 0 18px var(--button-bg), 0 0 45px var(--button-bg), 0 0 10px #fff, inset 0 0 8px rgba(255,255,255,0.7);
            transform: translateY(-3px) scale(1.03);
            filter: brightness(1.15);
        }

        #drop-button:active:not(:disabled) {
            transform: translateY(1px) scale(1.01);
            box-shadow: 0 0 8px var(--button-bg), 0 0 15px var(--button-bg), inset 0 0 6px rgba(0,0,0,0.3);
            filter: brightness(1.05);
        }

        #drop-button:disabled {
            background: #444;
            border-color: #666;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            filter: brightness(0.7);
        }

        #score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.8em;
            color: var(--score-color);
            text-shadow: 0 0 12px var(--score-color), 0 0 24px var(--score-color);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), text-shadow 0.3s ease;
             margin-bottom: 5px;
        }

        #score-display.score-update {
            transform: scale(1.15);
            text-shadow: 0 0 18px var(--score-color), 0 0 35px var(--score-color), 0 0 10px #fff;
        }

        #game-wrapper {
             position: relative;
             width: 90vw;
             max-width: 700px;
             height: calc(85vh - 120px);
             max-height: 900px;
             /* Ensure wrapper can contain absolutely positioned popups */
             overflow: visible;
        }

        #game-container {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(42, 10, 58, 0.8) 0%, rgba(42, 10, 58, 0.95) 70%, var(--background-color) 100%);
            border: 3px solid var(--primary-neon);
            border-radius: 10px;
            box-shadow: 0 0 25px var(--primary-neon), inset 0 0 18px rgba(255, 0, 255, 0.65);
            overflow: hidden; /* Keep hidden for physics bounds */
        }

        #score-popup {
            position: absolute;
            /* Position will be set dynamically via JS */
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            font-family: 'Orbitron', sans-serif;
            color: var(--score-popup-color);
            text-align: center;
            font-size: clamp(2em, 6vw, 3.5em);
            font-weight: 700;
            text-shadow: 0 0 12px var(--score-popup-color), 0 0 25px var(--score-popup-color), 0 0 5px #fff;
            transform: translate(-50%, -50%) scale(0.5); /* Start small and centered on target */
            /* Animation will be added via class */
        }

        #score-popup.show {
            animation: scorePopupAnimation 1.5s ease-out forwards;
        }

        @keyframes scorePopupAnimation {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0.7);
            }
            25% {
                transform: translate(-50%, -65%) scale(1.1); /* Move up slightly and overshoot size */
            }
             50% {
                transform: translate(-50%, -70%) scale(1); /* Settle size */
             }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%) scale(0.8); /* Move further up and fade out */
            }
        }


        .physics-object {
            position: absolute;
            box-sizing: border-box;
            transform-origin: center center;
        }

        .ball {
            background: var(--ball-gradient);
            border-radius: 50%;
            box-shadow: 0 0 12px var(--ball-color), 0 0 24px var(--ball-color), inset 0 0 6px rgba(255,255,255,0.6);
            z-index: 5;
            transition: opacity 0.3s ease-out;
        }

        .ball.removing {
            opacity: 0;
        }

        .peg {
            background: radial-gradient(circle, var(--peg-glow), var(--peg-color));
            border: 1px solid var(--peg-glow);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--peg-glow);
            transition: box-shadow 0.1s ease-out, background 0.1s ease-out, transform 0.1s ease-out;
            z-index: 1;
        }

        .peg-hit {
            background: radial-gradient(circle, var(--peg-hit-glow), var(--secondary-neon));
            box-shadow: 0 0 15px var(--peg-hit-glow), 0 0 30px var(--secondary-neon);
            transform: scale(1.25);
        }

        .divider {
            background-color: var(--divider-color);
            box-shadow: 0 0 8px var(--divider-color), 0 0 15px var(--divider-color);
            border-radius: 2px;
            z-index: 1;
        }

        .bucket-label {
            position: absolute;
            bottom: 5px;
            width: 10%;
            text-align: center;
            font-size: clamp(0.75rem, 2.3vw, 1.1rem); /* Slightly larger/bolder */
            font-weight: 700;
            color: var(--bucket-text-color);
            text-shadow: 0 0 7px var(--bucket-text-color), 0 0 12px rgba(57, 255, 20, 0.7); /* Adjusted shadow for green */
            z-index: 2;
            pointer-events: none;
        }
        /* .multiplier class removed */

        .particle {
            position: absolute;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 16; /* Above score popup maybe? Or below (14)? Let's try above */
            background: var(--particle-color);
            box-shadow: 0 0 6px var(--particle-color), 0 0 10px var(--particle-color);
            animation: burst 0.8s ease-out forwards;
        }

        @keyframes burst {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx, 0), var(--ty, -100px)) scale(0); opacity: 0; }
        }

        .trail-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: var(--ball-color);
            border-radius: 50%;
            pointer-events: none;
            animation: fade-out 0.4s ease-out forwards;
            z-index: 4;
            opacity: 0.8;
        }

        @keyframes fade-out {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.3); }
        }

        @keyframes burst-out {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        @media (max-width: 600px) {
            #game-wrapper { height: calc(88vh - 100px); }
            #score-display { font-size: 2.2em; }
            #drop-button { font-size: 1.2em; padding: 11px 28px; }
            .particle { width: 7px; height: 7px; }
            .trail-particle { width: 4px; height: 4px; }
             #score-popup { font-size: clamp(1.8em, 5vw, 3em); }
        }
         @media (max-height: 700px) {
              #game-wrapper { height: calc(80vh - 90px); }
         }

    </style>
</head>
<body>
    <div id="ui-container">
        <button id="drop-button">Drop Chip</button>
        <div id="score-display">Score: 0</div>
    </div>

    <div id="game-wrapper">
        <div id="game-container"></div>
        <!-- Score popup element, moved outside game-container but inside wrapper -->
        <div id="score-popup"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { Engine, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

            const gameWrapper = document.getElementById('game-wrapper');
            const gameContainer = document.getElementById('game-container');
            const dropButton = document.getElementById('drop-button');
            const scoreDisplay = document.getElementById('score-display');
            const scorePopup = document.getElementById('score-popup'); // Get the score popup element

            let containerWidth = gameContainer.clientWidth;
            let containerHeight = gameContainer.clientHeight;

            const engine = Engine.create({
                gravity: { x: 0, y: 0.6 },
                enableSleeping: true
            });
            const world = engine.world;
            const runner = Runner.create();

            let currentScore = 0;
            let ball = null;
            let isBallInPlay = false;
            let ballRemovalTimeout = null;
            let scorePopupTimeout = null; // Timeout for clearing popup animation class

            let pegRadius = Math.min(containerWidth * 0.015, 7);
            let ballRadius = Math.min(containerWidth * 0.023, 13);
            const numRows = 11;
            const numCols = 9;
            let horizontalSpacing = containerWidth / (numCols + 1);
            let verticalSpacing = (containerHeight * 0.65) / numRows;
            const startYOffset = containerHeight * 0.1;

            // Bucket values remain the same, but 2x multiplier logic is removed
            const bucketValues = [5000, 10000, 25000, 50000, 100000, 50000, 25000, 10000, 5000];
            const numBuckets = bucketValues.length;
            let bucketWidth = containerWidth / numBuckets;
            const bucketHeight = containerHeight * 0.1;
            let dividerHeight = bucketHeight * 1.2;
            let dividerWidth = Math.max(3, containerWidth * 0.006);
            const bucketBaseY = containerHeight - bucketHeight / 2;
            const bucketTriggerY = containerHeight - bucketHeight * 1.1;
            // centerBucketIndex is no longer needed for multiplier logic

            const pegMap = new Map();

            let audioContext;

            function initAudio() {
                if (!audioContext) {
                    try {
                         audioContext = new (window.AudioContext || window.webkitAudioContext)();
                         if (audioContext.state === 'suspended') {
                             const resume = async () => {
                                 await audioContext.resume();
                                 document.body.removeEventListener('click', resume);
                                 document.body.removeEventListener('touchend', resume);
                             };
                             document.body.addEventListener('click', resume);
                             document.body.addEventListener('touchend', resume);
                         }
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser");
                    }
                }
            }

            function playTone(frequency, type = 'triangle', duration = 0.1, volume = 0.3, delay = 0) {
                if (!audioContext || audioContext.state === 'suspended') return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const now = audioContext.currentTime + delay;

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, now);

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(now);
                oscillator.stop(now + duration);
            }

            function playDropSound() {
                playTone(150, 'sine', 0.3, 0.4);
            }

            function playPegHitSound() {
                 const randomPitch = 650 + Math.random() * 350;
                 playTone(randomPitch, 'triangle', 0.07, 0.18);
            }

            // Removed isCenter parameter and logic
            function playBucketSound(value) {
                 const minValue = 5000;
                 const maxValue = 100000;
                 const minFreq = 180; // C#3
                 const maxFreq = 880; // A5 - Increased max frequency for more range

                 // Logarithmic scaling for frequency based on value
                 const ratio = (Math.log(value) - Math.log(minValue)) / (Math.log(maxValue) - Math.log(minValue));
                 const freq = minFreq * Math.pow(maxFreq / minFreq, Math.max(0, Math.min(1, ratio)));

                 const duration = 0.3 + ratio * 0.2; // Longer duration for higher values
                 const volume = 0.4 + ratio * 0.2; // Louder for higher values
                 const waveType = 'triangle'; // Consistent wave type

                 playTone(freq, waveType, duration, volume);
                 // Add a subtle harmony or effect based on frequency
                 playTone(freq * 1.5, 'sine', duration * 0.6, volume * 0.4, duration * 0.1); // Add a fifth harmonic softly
            }

            function createDOMElement(body) {
                const div = document.createElement('div');
                div.classList.add('physics-object');
                if (body.label === 'ball') {
                    div.classList.add('ball');
                    div.style.width = `${ballRadius * 2}px`;
                    div.style.height = `${ballRadius * 2}px`;
                } else if (body.label === 'peg') {
                    div.classList.add('peg');
                    div.style.width = `${pegRadius * 2}px`;
                    div.style.height = `${pegRadius * 2}px`;
                    pegMap.set(body.id, div);
                } else if (body.label === 'divider') {
                    div.classList.add('divider');
                } else if (body.label === 'wall') {
                    div.style.backgroundColor = 'transparent';
                }
                gameContainer.appendChild(div);
                body.domElement = div;
                syncDOM(body);
                return div;
            }

            function syncDOM(body) {
                if (!body.domElement) return;
                const pos = body.position;
                const angle = body.angle;
                const element = body.domElement;
                let width, height;
                if (body.label === 'ball') width = height = ballRadius * 2;
                else if (body.label === 'peg') width = height = pegRadius * 2;
                else if (body.label === 'divider' || body.label === 'wall') {
                    width = body.bounds.max.x - body.bounds.min.x;
                    height = body.bounds.max.y - body.bounds.min.y;
                } else {
                    width = element.offsetWidth;
                    height = element.offsetHeight;
                }
                element.style.transform = `translate(${pos.x - width / 2}px, ${pos.y - height / 2}px) rotate(${angle}rad)`;
                if ((body.label === 'divider' || body.label === 'wall') && (!element.style.width || !element.style.height)) {
                    element.style.width = `${width}px`;
                    element.style.height = `${height}px`;
                }
            }

            function createPegs() {
                Composite.remove(world, world.bodies.filter(body => body.label === 'peg'), true);
                pegMap.clear();
                gameContainer.querySelectorAll('.peg').forEach(el => el.remove());
                const pegs = [];
                for (let row = 0; row < numRows; row++) {
                    const colsInRow = numCols + (row % 2 === 0 ? 0 : -1);
                    const rowOffsetY = startYOffset + row * verticalSpacing;
                    const rowOffsetX = (containerWidth - (colsInRow - 1) * horizontalSpacing) / 2;
                    for (let col = 0; col < colsInRow; col++) {
                        const x = rowOffsetX + col * horizontalSpacing;
                        const y = rowOffsetY;
                        const peg = Bodies.circle(x, y, pegRadius, {
                            isStatic: true,
                            label: 'peg',
                            friction: 0.05,
                            restitution: 0.45,
                            render: { visible: false }
                        });
                        pegs.push(peg);
                        createDOMElement(peg);
                    }
                }
                Composite.add(world, pegs);
            }

            function createBoundaries() {
                Composite.remove(world, world.bodies.filter(body => body.label === 'divider' || body.label === 'wall'), true);
                gameContainer.querySelectorAll('.divider, .bucket-label').forEach(el => el.remove());
                const dividers = [];
                for (let i = 0; i <= numBuckets; i++) {
                    const x = i * bucketWidth;
                    const y = containerHeight - dividerHeight / 2;
                    const divider = Bodies.rectangle(x, y, dividerWidth, dividerHeight, {
                        isStatic: true,
                        label: 'divider',
                        friction: 0.3,
                        render: { visible: false }
                    });
                    dividers.push(divider);
                     if (i > 0 && i < numBuckets) {
                         const domEl = createDOMElement(divider);
                         domEl.style.height = `${dividerHeight}px`;
                         domEl.style.width = `${dividerWidth}px`;
                     } else {
                         const edgeWall = Bodies.rectangle(x, y, dividerWidth, dividerHeight, {
                            isStatic: true, label: 'wall', render: { visible: false }
                         });
                         Composite.add(world, edgeWall);
                     }
                }
                Composite.add(world, dividers.slice(1, -1));

                for (let i = 0; i < numBuckets; i++) {
                    const label = document.createElement('div');
                    label.classList.add('bucket-label');
                    let labelText = (bucketValues[i] / 1000) + 'k';
                    if (bucketValues[i] >= 1000000) labelText = (bucketValues[i] / 1000000) + 'm';
                    // Removed [2x] and multiplier class logic
                    label.textContent = labelText;
                    label.style.left = `${i * bucketWidth}px`;
                    label.style.width = `${bucketWidth}px`;
                    label.style.bottom = `${dividerHeight * 0.08}px`;
                    gameContainer.appendChild(label);
                }
                const wallThickness = 50;
                Composite.add(world, [
                    Bodies.rectangle(containerWidth / 2, containerHeight + wallThickness / 2 - 5, containerWidth + wallThickness * 2, wallThickness, { isStatic: true, label: 'wall', render: { visible: false } }), // Floor
                     Bodies.rectangle(-wallThickness / 2, containerHeight / 2, wallThickness, containerHeight * 2, { isStatic: true, label: 'wall', render: { visible: false } }), // Left
                     Bodies.rectangle(containerWidth + wallThickness / 2, containerHeight / 2, wallThickness, containerHeight * 2, { isStatic: true, label: 'wall', render: { visible: false } }) // Right
                ]);
                 const funnelAngle = Math.PI / 6;
                 const funnelLength = containerWidth * 0.3;
                 const funnelY = startYOffset * 0.6;
                 Composite.add(world, [
                     Bodies.rectangle(containerWidth * 0.2, funnelY, funnelLength, 10, { isStatic: true, angle: funnelAngle, label: 'wall', render: {fillStyle: '#ff00ff'}}),
                     Bodies.rectangle(containerWidth * 0.8, funnelY, funnelLength, 10, { isStatic: true, angle: -funnelAngle, label: 'wall', render: {fillStyle: '#ff00ff'}})
                 ]);
            }

            function removeBall(ballBody, immediate = false) {
                if (!ballBody) return;
                clearTimeout(ballRemovalTimeout);
                if (ballBody.domElement) {
                    if (immediate) {
                         if (ballBody.domElement.parentNode) ballBody.domElement.remove();
                    }
                    else {
                        ballBody.domElement.classList.add('removing');
                        ballRemovalTimeout = setTimeout(() => {
                             if (ballBody.domElement && ballBody.domElement.parentNode) ballBody.domElement.remove();
                            if (world.bodies.includes(ballBody)) Composite.remove(world, ballBody);
                            if (ball === ballBody) ball = null;
                        }, 300);
                    }
                }
                if (immediate && world.bodies.includes(ballBody)) Composite.remove(world, ballBody);
                if (ball === ballBody) ball = null;
                if (!immediate && isBallInPlay) {
                    isBallInPlay = false;
                    dropButton.disabled = false;
                }
            }

            // Function to show the score popup animation
            function showScorePopup(amount, x, y) {
                 scorePopup.textContent = `+${amount.toLocaleString()}!`;
                 // Position the popup roughly above the bucket center
                 scorePopup.style.left = `${x}px`;
                 scorePopup.style.top = `${y - 30}px`; // Adjust vertical offset as needed

                 scorePopup.classList.add('show');

                 // Clear any existing timeout to reset the animation state removal
                 clearTimeout(scorePopupTimeout);
                 // Remove the class after the animation completes (1.5s)
                 scorePopupTimeout = setTimeout(() => {
                     scorePopup.classList.remove('show');
                     scorePopup.textContent = ''; // Clear text after fade out
                 }, 1500);
            }


            function dropBall() {
                if (isBallInPlay) return;
                initAudio();
                playDropSound();
                isBallInPlay = true;
                dropButton.disabled = true;
                // No overlay clearing needed

                const randomOffsetX = (Math.random() - 0.5) * horizontalSpacing * 0.3;
                const startX = containerWidth / 2 + randomOffsetX;
                const startY = startYOffset * 0.2;

                ball = Bodies.circle(startX, startY, ballRadius, {
                    label: 'ball',
                    friction: 0.03,
                    frictionAir: 0.004,
                    restitution: 0.3,
                    density: 0.0018,
                    sleepThreshold: 120,
                    render: { visible: false }
                });
                createDOMElement(ball);
                Composite.add(world, ball);
                ballRemovalTimeout = setTimeout(() => {
                    if (isBallInPlay && ball) {
                         showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8); // Show "Lost" popup
                        removeBall(ball);
                    }
                }, 25000);
            }

            function handlePegHit(pegBody) {
                const pegElement = pegMap.get(pegBody.id);
                if (pegElement && !pegElement.classList.contains('peg-hit')) {
                    pegElement.classList.add('peg-hit');
                    playPegHitSound();
                    setTimeout(() => pegElement.classList.remove('peg-hit'), 150);
                    const count = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        const particle = document.createElement('div');
                        particle.classList.add('particle');
                        particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 40}px`);
                        particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 40}px`);
                        particle.style.left = `${pegBody.position.x - 4.5}px`;
                        particle.style.top = `${pegBody.position.y - 4.5}px`;
                        particle.style.background = 'var(--secondary-neon)';
                        particle.style.boxShadow = `0 0 7px var(--secondary-neon), 0 0 12px var(--secondary-neon)`;
                        particle.style.animation = 'burst-out 0.5s ease-out forwards';
                        particle.style.width = '6px';
                        particle.style.height = '6px';
                        gameContainer.appendChild(particle);
                        setTimeout(() => particle.remove(), 500);
                    }
                }
            }

             // Removed isSuccess parameter
             function triggerEndParticles(x, y, value) {
                 const baseCount = 25; // Adjusted base count
                 const valueFactor = Math.log10(value / 1000 + 1);
                 const count = baseCount + Math.floor(valueFactor * 12); // Adjusted scaling
                 const spread = 180 + valueFactor * 40; // Spread based on value
                 const upwardVelocity = -220 - valueFactor * 80; // Velocity based on value
                 const duration = 0.9 + valueFactor * 0.3; // Duration based on value
                 const primaryColor = value > 40000 ? 'var(--primary-neon)' : 'var(--tertiary-neon)'; // Color depends on value
                 const secondaryColor = 'var(--secondary-neon)';

                 playBucketSound(value); // Play sound based on value

                 setTimeout(() => {
                     for (let i = 0; i < count; i++) {
                         const particle = document.createElement('div');
                         particle.classList.add('particle');
                         const angle = Math.random() * Math.PI * 2;
                         const distance = Math.random() * spread;
                         const tx = Math.cos(angle) * distance;
                         const ty = upwardVelocity + (Math.random() - 0.5) * 100;
                         particle.style.setProperty('--tx', `${tx}px`);
                         particle.style.setProperty('--ty', `${ty}px`);
                         particle.style.left = `${x - 4.5}px`;
                         particle.style.top = `${y - 4.5}px`;
                         particle.style.background = Math.random() > 0.5 ? primaryColor : secondaryColor;
                         particle.style.boxShadow = `0 0 7px ${particle.style.background}, 0 0 12px ${particle.style.background}`;
                         particle.style.animationDuration = `${duration + Math.random() * 0.2}s`;
                         // Add to gameWrapper so particles appear over game-container
                         gameWrapper.appendChild(particle);
                         setTimeout(() => particle.remove(), (duration + Math.random() * 0.2) * 1000);
                     }
                 }, 50);
             }

            // Removed updateScore function, logic moved to tick handler

            function handleResize() {
                // Recalculate dimensions
                 containerWidth = gameContainer.clientWidth;
                 containerHeight = gameContainer.clientHeight;

                // Update physics parameters based on new dimensions
                 pegRadius = Math.min(containerWidth * 0.015, 7);
                 ballRadius = Math.min(containerWidth * 0.023, 13);
                 horizontalSpacing = containerWidth / (numCols + 1);
                 verticalSpacing = (containerHeight * 0.65) / numRows;
                 bucketWidth = containerWidth / numBuckets;
                 dividerWidth = Math.max(3, containerWidth * 0.006);
                 dividerHeight = bucketHeight * 1.2;

                 // Remove current ball if it exists
                 if (ball) removeBall(ball, true);
                 isBallInPlay = false;
                 dropButton.disabled = false;

                 // Clear physics world and DOM elements inside game container
                 Composite.clear(world, false);
                 Engine.clear(engine);
                 gameContainer.innerHTML = '';
                 pegMap.clear();

                 // Recreate static elements
                 createPegs();
                 createBoundaries(); // This also re-adds walls and funnel

                 // Sync DOM for newly added static elements if necessary
                 Composite.allBodies(world).forEach(body => {
                     if (body.isStatic && body.domElement) syncDOM(body);
                 });
            }

            createPegs();
            createBoundaries();

            let trailCounter = 0;
            Events.on(runner, 'tick', () => {
                const bodies = Composite.allBodies(world);
                for (let i = 0; i < bodies.length; i++) {
                     if (!bodies[i].isStatic || bodies[i].domElement) {
                         syncDOM(bodies[i]);
                     }
                }
                if (ball && isBallInPlay) {
                    trailCounter++;
                    if (trailCounter >= 2) {
                        trailCounter = 0;
                        const particle = document.createElement('div');
                        particle.classList.add('trail-particle');
                        particle.style.left = `${ball.position.x - 2.5}px`;
                        particle.style.top = `${ball.position.y - 2.5}px`;
                        gameContainer.appendChild(particle);
                        setTimeout(() => particle.remove(), 400);
                    }
                }
                if (ball && isBallInPlay && ball.position.y > bucketTriggerY && !ball.isSleeping) {
                    const ballX = ball.position.x;
                    const speed = Vector.magnitude(ball.velocity);
                    const isSettling = speed < 0.15 && ball.position.y > (containerHeight - bucketHeight * 0.8);

                    if (ballX >= 0 && ballX <= containerWidth) {
                        const bucketIndex = Math.floor(ballX / bucketWidth);
                        if (isSettling && bucketIndex >= 0 && bucketIndex < numBuckets) {
                            const scoreValue = bucketValues[bucketIndex]; // No multiplier
                            const bucketCenterX = (bucketIndex + 0.5) * bucketWidth;
                            const bucketEffectY = containerHeight - bucketHeight * 0.3;

                            // Trigger particles and sound
                            triggerEndParticles(bucketCenterX, bucketEffectY, scoreValue);

                            // Update score state
                            currentScore += scoreValue;
                            scoreDisplay.textContent = `Score: ${currentScore.toLocaleString()}`;
                            scoreDisplay.classList.add('score-update');
                            setTimeout(() => scoreDisplay.classList.remove('score-update'), 300);

                            // Show score popup
                            showScorePopup(scoreValue, bucketCenterX, bucketEffectY);

                            removeBall(ball); // Remove ball, enable drop button

                        } else if (isSettling) {
                             showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                             removeBall(ball);
                        }
                    } else if (isSettling) {
                         showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                         removeBall(ball);
                    }
                } else if (ball && isBallInPlay && ball.position.y > containerHeight + ballRadius * 5) {
                     showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                     removeBall(ball);
                }
            });

            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    let pegBody = null;
                    let ballBody = null;
                    if (pair.bodyA.label === 'ball' && pair.bodyB.label === 'peg') {
                        pegBody = pair.bodyB;
                        ballBody = pair.bodyA;
                    } else if (pair.bodyB.label === 'ball' && pair.bodyA.label === 'peg') {
                        pegBody = pair.bodyA;
                        ballBody = pair.bodyB;
                    }
                    if (pegBody && ballBody === ball) {
                        handlePegHit(pegBody);
                        if (ballBody.isSleeping) Body.setSleeping(ballBody, false);
                    }
                }
            });

            dropButton.addEventListener('click', () => {
                 initAudio();
                 dropBall();
            });
            window.addEventListener('resize', handleResize);
            Runner.run(runner, engine);

             handleResize(); // Initial size calculation
        });
    </script>
</body>
</html>
