<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;700&display=swap');

        :root {
            --background-color: #1c082a;
            --background-glow-1: rgba(74, 20, 140, 0.4);
            --background-glow-2: rgba(171, 71, 188, 0.3);
            --primary-neon: #ff00ff;
            --secondary-neon: #00ffff;
            --tertiary-neon: #f7ff00;
            --peg-color: #4a148c;
            --peg-glow: #e040fb;
            --peg-hit-glow: #ffffff;

            --ball-color-1: #f7ff00;
            --ball-gradient-1: radial-gradient(circle, #ffffae, var(--ball-color-1));
            --ball-color-2: #00ffff;
            --ball-gradient-2: radial-gradient(circle, #aeffff, var(--ball-color-2));
            --ball-color-3: #ff00ff;
            --ball-gradient-3: radial-gradient(circle, #ffafff, var(--ball-color-3));
            --ball-color-4: #39ff14;
            --ball-gradient-4: radial-gradient(circle, #afffaf, var(--ball-color-4));
            --ball-color-5: #ffa500;
            --ball-gradient-5: radial-gradient(circle, #ffdca0, var(--ball-color-5));
            --ball-color-6: #ff1493;
            --ball-gradient-6: radial-gradient(circle, #ffabcd, var(--ball-color-6));
            --ball-color-7: #0077ff;
            --ball-gradient-7: radial-gradient(circle, #a0cfff, var(--ball-color-7));
            --ball-color-8: #7fff00;
            --ball-gradient-8: radial-gradient(circle, #d0ffaf, var(--ball-color-8));
            --ball-color-9: #ff0000;
            --ball-gradient-9: radial-gradient(circle, #ffaaaa, var(--ball-color-9));
            --ball-color-10: #a020f0;
            --ball-gradient-10: radial-gradient(circle, #e0b0ff, var(--ball-color-10));

            --divider-color: var(--primary-neon);
            --bucket-text-color: #39ff14;
            --button-bg: var(--primary-neon);
            --button-text: #1a0a2a;
            --button-cyan-bg: var(--secondary-neon);
            --button-cyan-text: #051a2a;
            --score-color: var(--tertiary-neon);
            --particle-color: var(--primary-neon);
            --score-popup-color: var(--tertiary-neon);
        }

        body {
            background-color: var(--background-color);
            color: var(--primary-neon);
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            overflow: hidden;
            text-shadow: 0 0 7px var(--primary-neon);
            position: relative;
        }

        body::before, body::after {
            content: '';
            position: absolute;
            inset: 0;
            z-index: -1;
            pointer-events: none;
        }

        body::before {
            background:
                radial-gradient(circle at 20% 30%, var(--background-glow-1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, var(--background-glow-2) 0%, transparent 50%);
            animation: backgroundGlow 25s ease-in-out infinite alternate;
        }

        body::after {
             background:
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><path d="M0 0 L40 0 M0 0 L0 40" stroke="%23ff00ff" stroke-width="0.3" opacity="0.08" /></svg>'),
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
             background-size: 20px 20px, 5px 5px, 5px 5px;
             animation: backgroundSubtleMove 40s linear infinite;
        }


        @keyframes backgroundGlow {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }

         @keyframes backgroundSubtleMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 80px 80px, 5px 5px, 5px 5px; }
        }


        #ui-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        #button-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .drop-button {
            color: var(--button-text);
            border: 2px solid;
            padding: 13px 32px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2.5px;
            border-radius: 6px;
            transition: all 0.25s ease;
        }

        #drop-button {
            background: linear-gradient(145deg, var(--primary-neon), #c000c0);
            border-color: var(--primary-neon);
            box-shadow: 0 0 12px var(--button-bg), 0 0 25px var(--button-bg), inset 0 0 5px rgba(255,255,255,0.5);
            color: var(--button-text);
        }

        #drop-multiple-button {
            background: linear-gradient(145deg, var(--secondary-neon), #00c0c0);
            border-color: var(--secondary-neon);
            box-shadow: 0 0 12px var(--button-cyan-bg), 0 0 25px var(--button-cyan-bg), inset 0 0 5px rgba(255,255,255,0.5);
            color: var(--button-cyan-text);
        }


        .drop-button:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.03);
            filter: brightness(1.15);
        }
        #drop-button:hover:not(:disabled) {
            box-shadow: 0 0 18px var(--button-bg), 0 0 45px var(--button-bg), 0 0 10px #fff, inset 0 0 8px rgba(255,255,255,0.7);
        }
        #drop-multiple-button:hover:not(:disabled) {
            box-shadow: 0 0 18px var(--button-cyan-bg), 0 0 45px var(--button-cyan-bg), 0 0 10px #fff, inset 0 0 8px rgba(255,255,255,0.7);
        }

        .drop-button:active:not(:disabled) {
            transform: translateY(1px) scale(1.01);
            filter: brightness(1.05);
        }
        #drop-button:active:not(:disabled) {
             box-shadow: 0 0 8px var(--button-bg), 0 0 15px var(--button-bg), inset 0 0 6px rgba(0,0,0,0.3);
        }
         #drop-multiple-button:active:not(:disabled) {
             box-shadow: 0 0 8px var(--button-cyan-bg), 0 0 15px var(--button-cyan-bg), inset 0 0 6px rgba(0,0,0,0.3);
        }

        .drop-button:disabled {
            background: #444;
            border-color: #666;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            filter: brightness(0.7);
            transform: none;
        }

        #score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.8em;
            color: var(--score-color);
            text-shadow: 0 0 12px var(--score-color), 0 0 24px var(--score-color);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), text-shadow 0.3s ease;
             margin-bottom: 5px;
        }

        #score-display.score-update {
            transform: scale(1.15);
            text-shadow: 0 0 18px var(--score-color), 0 0 35px var(--score-color), 0 0 10px #fff;
        }

        #game-wrapper {
             position: relative;
             width: 90vw;
             max-width: 700px;
             height: calc(85vh - 130px);
             max-height: 900px;
             overflow: visible;
        }

        #game-container {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(42, 10, 58, 0.8) 0%, rgba(42, 10, 58, 0.95) 70%, var(--background-color) 100%);
            border: 3px solid var(--primary-neon);
            border-radius: 10px;
            box-shadow: 0 0 25px var(--primary-neon), inset 0 0 18px rgba(255, 0, 255, 0.65);
            overflow: hidden;
        }

        #score-popup {
            position: absolute;
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            font-family: 'Orbitron', sans-serif;
            color: var(--score-popup-color);
            text-align: center;
            font-size: clamp(2em, 6vw, 3.5em);
            font-weight: 700;
            text-shadow: 0 0 12px var(--score-popup-color), 0 0 25px var(--score-popup-color), 0 0 5px #fff;
            transform: translate(-50%, -50%) scale(0.5);
        }

        #score-popup.show {
            animation: scorePopupAnimation 1.5s ease-out forwards;
        }

        @keyframes scorePopupAnimation {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.7); }
            25% { transform: translate(-50%, -65%) scale(1.1); }
            50% { transform: translate(-50%, -70%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); }
        }


        .physics-object {
            position: absolute;
            box-sizing: border-box;
            transform-origin: center center;
        }

        .ball {
            border-radius: 50%;
            z-index: 5;
            transition: opacity 0.3s ease-out;
        }

        .ball.removing {
            opacity: 0;
        }

        .peg {
            background: radial-gradient(circle, var(--peg-glow), var(--peg-color));
            border: 1px solid var(--peg-glow);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--peg-glow);
            transition: box-shadow 0.1s ease-out, background 0.1s ease-out, transform 0.1s ease-out;
            z-index: 1;
        }

        .peg-hit {
            background: radial-gradient(circle, var(--peg-hit-glow), var(--secondary-neon));
            box-shadow: 0 0 15px var(--peg-hit-glow), 0 0 30px var(--secondary-neon);
            transform: scale(1.25);
        }

        .divider {
            background-color: var(--divider-color);
            box-shadow: 0 0 8px var(--divider-color), 0 0 15px var(--divider-color);
            border-radius: 2px;
            z-index: 1;
        }

        .bucket-label {
            position: absolute;
            bottom: 5px;
            width: 10%;
            text-align: center;
            font-size: clamp(0.75rem, 2.3vw, 1.1rem);
            font-weight: 700;
            color: var(--bucket-text-color);
            text-shadow: 0 0 7px var(--bucket-text-color), 0 0 12px rgba(57, 255, 20, 0.7);
            z-index: 2;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 16;
            background: var(--particle-color);
            box-shadow: 0 0 6px var(--particle-color), 0 0 10px var(--particle-color);
            animation: burst 0.8s ease-out forwards;
        }

        @keyframes burst {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx, 0), var(--ty, -100px)) scale(0); opacity: 0; }
        }

        .trail-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            pointer-events: none;
            animation: fade-out 0.4s ease-out forwards;
            z-index: 4;
            opacity: 0.8;
        }

        @keyframes fade-out {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.3); }
        }

        @keyframes burst-out {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        @media (max-width: 600px) {
            #game-wrapper { height: calc(88vh - 110px); }
            #score-display { font-size: 2.2em; }
            .drop-button { font-size: 1.2em; padding: 11px 28px; }
            .particle { width: 7px; height: 7px; }
            .trail-particle { width: 4px; height: 4px; }
             #score-popup { font-size: clamp(1.8em, 5vw, 3em); }
        }
         @media (max-height: 700px) {
              #game-wrapper { height: calc(80vh - 100px); }
         }

    </style>
</head>
<body>
    <div id="ui-container">
        <div id="button-row">
             <button id="drop-button" class="drop-button">Drop Chip</button>
             <button id="drop-multiple-button" class="drop-button">Drop 5</button>
        </div>
        <div id="score-display">Score: 0</div>
    </div>

    <div id="game-wrapper">
        <div id="game-container"></div>
        <div id="score-popup"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { Engine, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

            const gameWrapper = document.getElementById('game-wrapper');
            const gameContainer = document.getElementById('game-container');
            const dropButton = document.getElementById('drop-button');
            const dropMultipleButton = document.getElementById('drop-multiple-button');
            const scoreDisplay = document.getElementById('score-display');
            const scorePopup = document.getElementById('score-popup');

            let containerWidth = gameContainer.clientWidth;
            let containerHeight = gameContainer.clientHeight;

            const engine = Engine.create({
                gravity: { x: 0, y: 0.7 },
                enableSleeping: true,
                positionIterations: 8,
                velocityIterations: 6
            });
            const world = engine.world;
            const runner = Runner.create();

            let currentScore = 0;
            const maxBalls = 10;
            let activeBalls = [];
            let activeBallCount = 0;
            let scorePopupTimeout = null;
            let nextBallColorIndex = 0;

            const STUCK_SPEED_THRESHOLD = 0.07;
            const ANGULAR_VELOCITY_THRESHOLD = 0.04;
            const STUCK_TIME_MS = 700;
            const STUCK_NUDGE_FORCE = 0.00035;

            const createShadow = (colorVar) => `0 0 10px var(${colorVar}), 0 0 20px var(${colorVar}), inset 0 0 5px rgba(255,255,255,0.65)`;

            const ballColors = [
                { gradient: 'var(--ball-gradient-1)', colorVar: '--ball-color-1', color: 'var(--ball-color-1)', shadow: createShadow('--ball-color-1') },
                { gradient: 'var(--ball-gradient-2)', colorVar: '--ball-color-2', color: 'var(--ball-color-2)', shadow: createShadow('--ball-color-2') },
                { gradient: 'var(--ball-gradient-3)', colorVar: '--ball-color-3', color: 'var(--ball-color-3)', shadow: createShadow('--ball-color-3') },
                { gradient: 'var(--ball-gradient-4)', colorVar: '--ball-color-4', color: 'var(--ball-color-4)', shadow: createShadow('--ball-color-4') },
                { gradient: 'var(--ball-gradient-5)', colorVar: '--ball-color-5', color: 'var(--ball-color-5)', shadow: createShadow('--ball-color-5') },
                { gradient: 'var(--ball-gradient-6)', colorVar: '--ball-color-6', color: 'var(--ball-color-6)', shadow: createShadow('--ball-color-6') },
                { gradient: 'var(--ball-gradient-7)', colorVar: '--ball-color-7', color: 'var(--ball-color-7)', shadow: createShadow('--ball-color-7') },
                { gradient: 'var(--ball-gradient-8)', colorVar: '--ball-color-8', color: 'var(--ball-color-8)', shadow: createShadow('--ball-color-8') },
                { gradient: 'var(--ball-gradient-9)', colorVar: '--ball-color-9', color: 'var(--ball-color-9)', shadow: createShadow('--ball-color-9') },
                { gradient: 'var(--ball-gradient-10)', colorVar: '--ball-color-10', color: 'var(--ball-color-10)', shadow: createShadow('--ball-color-10') }
            ];

            let pegRadius = Math.min(containerWidth * 0.015, 7);
            let ballRadius = Math.min(containerWidth * 0.023, 13);
            const numRows = 11;
            const numCols = 9;
            let horizontalSpacing = containerWidth / (numCols + 1);
            let verticalSpacing = (containerHeight * 0.65) / numRows;
            const startYOffset = containerHeight * 0.1;

            const bucketValues = [5000, 10000, 25000, 50000, 100000, 50000, 25000, 10000, 5000];
            const numBuckets = bucketValues.length;
            let bucketWidth = containerWidth / numBuckets;
            const bucketHeight = containerHeight * 0.1;
            let dividerHeight = bucketHeight * 1.2;
            let dividerWidth = Math.max(3, containerWidth * 0.006);
            const bucketBaseY = containerHeight - bucketHeight / 2;
            const bucketTriggerY = containerHeight - bucketHeight * 1.1;

            const pegMap = new Map();
            let audioContext;

            function initAudio() {
                if (!audioContext) {
                    try {
                         audioContext = new (window.AudioContext || window.webkitAudioContext)();
                         if (audioContext.state === 'suspended') {
                             const resume = async () => {
                                 await audioContext.resume();
                                 document.body.removeEventListener('click', resume);
                                 document.body.removeEventListener('touchend', resume);
                             };
                             document.body.addEventListener('click', resume);
                             document.body.addEventListener('touchend', resume);
                         }
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser");
                    }
                }
            }

            function playTone(frequency, type = 'triangle', duration = 0.1, volume = 0.3, delay = 0) {
                if (!audioContext || audioContext.state === 'suspended') return;
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    const now = audioContext.currentTime + delay;
                    oscillator.type = type;
                    oscillator.frequency.setValueAtTime(frequency, now);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.start(now);
                    oscillator.stop(now + duration);
                } catch (e) {
                    console.error("Error playing tone:", e);
                }
            }

            function playDropSound() { playTone(150, 'sine', 0.3, 0.4); }
            function playPegHitSound() { playTone(650 + Math.random() * 350, 'triangle', 0.07, 0.18); }

            function playBucketSound(value) {
                 const minValue = 5000;
                 const maxValue = 100000;
                 const minFreq = 180;
                 const maxFreq = 880;
                 const ratio = (Math.log(value) - Math.log(minValue)) / (Math.log(maxValue) - Math.log(minValue));
                 const freq = minFreq * Math.pow(maxFreq / minFreq, Math.max(0, Math.min(1, ratio)));
                 const duration = 0.3 + ratio * 0.2;
                 const volume = 0.4 + ratio * 0.2;
                 const waveType = 'triangle';
                 playTone(freq, waveType, duration, volume);
                 playTone(freq * 1.5, 'sine', duration * 0.6, volume * 0.4, duration * 0.1);
            }

            function createDOMElement(body) {
                const div = document.createElement('div');
                div.classList.add('physics-object');
                if (body.label === 'ball') {
                    div.classList.add('ball');
                    div.style.width = `${ballRadius * 2}px`;
                    div.style.height = `${ballRadius * 2}px`;
                    div.style.background = body.ballColor.gradient;
                    div.style.boxShadow = body.ballColor.shadow;
                } else if (body.label === 'peg') {
                    div.classList.add('peg');
                    div.style.width = `${pegRadius * 2}px`;
                    div.style.height = `${pegRadius * 2}px`;
                    pegMap.set(body.id, div);
                } else if (body.label === 'divider') {
                    div.classList.add('divider');
                } else if (body.label === 'wall') {
                    div.style.backgroundColor = 'transparent';
                }
                gameContainer.appendChild(div);
                body.domElement = div;
                syncDOM(body);
                return div;
            }

            function syncDOM(body) {
                if (!body.domElement || !body.domElement.parentNode) return;
                const pos = body.position;
                const angle = body.angle;
                const element = body.domElement;
                let width, height;
                if (body.label === 'ball') width = height = ballRadius * 2;
                else if (body.label === 'peg') width = height = pegRadius * 2;
                else if (body.label === 'divider' || body.label === 'wall') {
                    width = body.bounds.max.x - body.bounds.min.x;
                    height = body.bounds.max.y - body.bounds.min.y;
                } else {
                    width = element.offsetWidth;
                    height = element.offsetHeight;
                }

                 if (width > 0 && height > 0) {
                     element.style.transform = `translate(${pos.x - width / 2}px, ${pos.y - height / 2}px) rotate(${angle}rad)`;
                     if ((body.label === 'divider' || body.label === 'wall') && (!element.style.width || !element.style.height)) {
                         element.style.width = `${width}px`;
                         element.style.height = `${height}px`;
                     }
                 }
            }

            function createPegs() {
                Composite.remove(world, world.bodies.filter(body => body.label === 'peg'), true);
                pegMap.clear();
                gameContainer.querySelectorAll('.peg').forEach(el => el.remove());
                const pegs = [];
                for (let row = 0; row < numRows; row++) {
                    const colsInRow = numCols + (row % 2 === 0 ? 0 : -1);
                    const rowOffsetY = startYOffset + row * verticalSpacing;
                    const rowOffsetX = (containerWidth - (colsInRow - 1) * horizontalSpacing) / 2;
                    for (let col = 0; col < colsInRow; col++) {
                        const x = rowOffsetX + col * horizontalSpacing;
                        const y = rowOffsetY;
                        const peg = Bodies.circle(x, y, pegRadius, {
                            isStatic: true, label: 'peg',
                            friction: 0.015,
                            restitution: 0.55,
                            render: { visible: false }
                        });
                        pegs.push(peg);
                        createDOMElement(peg);
                    }
                }
                Composite.add(world, pegs);
            }

            function createBoundaries() {
                Composite.remove(world, world.bodies.filter(body => body.label === 'divider' || body.label === 'wall'), true);
                gameContainer.querySelectorAll('.divider, .bucket-label').forEach(el => el.remove());
                const staticBodies = [];

                for (let i = 0; i <= numBuckets; i++) {
                    const x = i * bucketWidth;
                    const y = containerHeight - dividerHeight / 2;
                     const isEdge = (i === 0 || i === numBuckets);
                     const divider = Bodies.rectangle(x, y, dividerWidth, dividerHeight, {
                         isStatic: true,
                         label: isEdge ? 'wall' : 'divider',
                         friction: 0.1,
                         restitution: 0.1,
                         render: { visible: false }
                     });
                     staticBodies.push(divider);
                     if (!isEdge) {
                         const domEl = createDOMElement(divider);
                         domEl.style.height = `${dividerHeight}px`;
                         domEl.style.width = `${dividerWidth}px`;
                     }
                }

                for (let i = 0; i < numBuckets; i++) {
                    const label = document.createElement('div');
                    label.classList.add('bucket-label');
                    let labelText = (bucketValues[i] / 1000) + 'k';
                    if (bucketValues[i] >= 1000000) labelText = (bucketValues[i] / 1000000) + 'm';
                    label.textContent = labelText;
                    label.style.left = `${i * bucketWidth}px`;
                    label.style.width = `${bucketWidth}px`;
                    label.style.bottom = `${dividerHeight * 0.08}px`;
                    gameContainer.appendChild(label);
                }

                const wallThickness = 50;
                staticBodies.push(
                    Bodies.rectangle(containerWidth / 2, containerHeight + wallThickness / 2 - 5, containerWidth + wallThickness * 2, wallThickness, { isStatic: true, label: 'wall', render: { visible: false } }),
                    Bodies.rectangle(-wallThickness / 2, containerHeight / 2, wallThickness, containerHeight * 2, { isStatic: true, label: 'wall', render: { visible: false } }),
                    Bodies.rectangle(containerWidth + wallThickness / 2, containerHeight / 2, wallThickness, containerHeight * 2, { isStatic: true, label: 'wall', render: { visible: false } })
                );

                 const funnelAngle = Math.PI / 6;
                 const funnelLength = containerWidth * 0.3;
                 const funnelY = startYOffset * 0.6;
                 staticBodies.push(
                     Bodies.rectangle(containerWidth * 0.2, funnelY, funnelLength, 10, { isStatic: true, angle: funnelAngle, label: 'wall', render: {fillStyle: 'transparent'}}),
                     Bodies.rectangle(containerWidth * 0.8, funnelY, funnelLength, 10, { isStatic: true, angle: -funnelAngle, label: 'wall', render: {fillStyle: 'transparent'}})
                 );

                 Composite.add(world, staticBodies);
            }

             function updateButtonStates() {
                 dropButton.disabled = activeBallCount >= maxBalls;
                 dropMultipleButton.disabled = activeBallCount > maxBalls - 5;
             }

            function removeBall(ballBody, immediate = false) {
                if (!ballBody || ballBody.isRemoving) return;
                ballBody.isRemoving = true;

                clearTimeout(ballBody.removalTimeout);
                const index = activeBalls.findIndex(b => b.id === ballBody.id);
                if (index > -1) {
                    activeBalls.splice(index, 1);
                    activeBallCount = activeBalls.length;
                } else {
                     activeBallCount = activeBalls.length;
                }

                if (ballBody.domElement) {
                    if (immediate) {
                         if (ballBody.domElement.parentNode) ballBody.domElement.remove();
                         ballBody.domElement = null;
                    } else {
                        ballBody.domElement.classList.add('removing');
                        setTimeout(() => {
                             if (ballBody.domElement && ballBody.domElement.parentNode) ballBody.domElement.remove();
                             ballBody.domElement = null;
                        }, 300);
                    }
                }

                const removalDelay = immediate ? 0 : 350;
                 setTimeout(() => {
                     if (world.bodies.includes(ballBody)) {
                         Composite.remove(world, ballBody);
                     }
                 }, removalDelay);

                updateButtonStates();
            }

            function showScorePopup(amount, x, y) {
                 if (!scorePopup) return;
                 scorePopup.textContent = typeof amount === 'number' ? `+${amount.toLocaleString()}!` : `${amount}!`;
                 scorePopup.style.left = `${x}px`;
                 scorePopup.style.top = `${y - 30}px`;
                 scorePopup.classList.add('show');
                 clearTimeout(scorePopupTimeout);
                 scorePopupTimeout = setTimeout(() => {
                    if (scorePopup) {
                        scorePopup.classList.remove('show');
                        scorePopup.textContent = '';
                    }
                 }, 1500);
            }

            function dropSingleBall() {
                 if (activeBallCount >= maxBalls) return null;

                 initAudio();

                 activeBallCount++;
                 updateButtonStates();

                 const randomOffsetX = (Math.random() - 0.5) * horizontalSpacing * 0.3;
                 const startX = containerWidth / 2 + randomOffsetX;
                 const startY = startYOffset * 0.2;

                 const colorInfo = ballColors[nextBallColorIndex % ballColors.length];
                 nextBallColorIndex++;

                 const newBall = Bodies.circle(startX, startY, ballRadius, {
                     label: 'ball',
                     friction: 0.004,
                     frictionAir: 0.003,
                     restitution: 0.5,
                     density: 0.0018,
                     sleepThreshold: 100,
                     render: { visible: false },
                     ballColor: colorInfo,
                     removalTimeout: null,
                     trailCounter: 0,
                     lastSlowTime: null,
                     isRemoving: false
                 });

                 createDOMElement(newBall);
                 Composite.add(world, newBall);
                 activeBalls.push(newBall);

                 newBall.removalTimeout = setTimeout(() => {
                     if (activeBalls.includes(newBall) && !newBall.isRemoving) {
                         console.warn(`Ball ${newBall.id} removed due to timeout.`);
                         showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                         removeBall(newBall);
                     }
                 }, 15000);

                return newBall;
            }

            function handlePegHit(pegBody) {
                const pegElement = pegMap.get(pegBody.id);
                if (pegElement && !pegElement.classList.contains('peg-hit')) {
                    pegElement.classList.add('peg-hit');
                    playPegHitSound();
                    setTimeout(() => pegElement.classList.remove('peg-hit'), 150);
                    const count = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        const particle = document.createElement('div');
                        particle.classList.add('particle');
                        particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 40}px`);
                        particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 40}px`);
                        particle.style.left = `${pegBody.position.x - 4.5}px`;
                        particle.style.top = `${pegBody.position.y - 4.5}px`;
                        particle.style.background = 'var(--secondary-neon)';
                        particle.style.boxShadow = `0 0 7px var(--secondary-neon), 0 0 12px var(--secondary-neon)`;
                        particle.style.animation = 'burst-out 0.5s ease-out forwards';
                        particle.style.width = '6px';
                        particle.style.height = '6px';
                        if (gameContainer && gameContainer.parentNode) {
                           gameContainer.appendChild(particle);
                           setTimeout(() => particle.remove(), 500);
                        }
                    }
                }
            }

             function triggerEndParticles(x, y, value) {
                 const baseCount = 20;
                 const valueFactor = Math.log10(value / 1000 + 1);
                 const count = baseCount + Math.floor(valueFactor * 10);
                 const spread = 180 + valueFactor * 35;
                 const upwardVelocity = -220 - valueFactor * 70;
                 const duration = 0.9 + valueFactor * 0.3;
                 const primaryColor = value > 40000 ? 'var(--primary-neon)' : 'var(--tertiary-neon)';
                 const secondaryColor = 'var(--secondary-neon)';

                 playBucketSound(value);

                 setTimeout(() => {
                     if (!gameWrapper || !gameWrapper.parentNode) return;
                     for (let i = 0; i < count; i++) {
                         const particle = document.createElement('div');
                         particle.classList.add('particle');
                         const angle = Math.random() * Math.PI * 2;
                         const distance = Math.random() * spread;
                         const tx = Math.cos(angle) * distance;
                         const ty = upwardVelocity + (Math.random() - 0.5) * 100;
                         particle.style.setProperty('--tx', `${tx}px`);
                         particle.style.setProperty('--ty', `${ty}px`);
                         particle.style.left = `${x - 4.5}px`;
                         particle.style.top = `${y - 4.5}px`;
                         particle.style.background = Math.random() > 0.3 ? primaryColor : (Math.random() > 0.5 ? secondaryColor : 'var(--ball-color-4)');
                         particle.style.boxShadow = `0 0 7px ${particle.style.background}, 0 0 12px ${particle.style.background}`;
                         particle.style.animationDuration = `${duration + Math.random() * 0.2}s`;
                         gameWrapper.appendChild(particle);
                         setTimeout(() => particle.remove(), (duration + Math.random() * 0.2) * 1000);
                     }
                 }, 50);
             }

            function handleResize() {
                 containerWidth = gameContainer.clientWidth;
                 containerHeight = gameContainer.clientHeight;

                 pegRadius = Math.min(containerWidth * 0.015, 7);
                 ballRadius = Math.min(containerWidth * 0.023, 13);
                 horizontalSpacing = containerWidth / (numCols + 1);
                 verticalSpacing = (containerHeight * 0.65) / numRows;
                 bucketWidth = containerWidth / numBuckets;
                 dividerWidth = Math.max(3, containerWidth * 0.006);
                 dividerHeight = bucketHeight * 1.2;

                 activeBalls.forEach(ballBody => removeBall(ballBody, true));
                 activeBalls = [];
                 activeBallCount = 0;
                 updateButtonStates();

                 Composite.clear(world, false);
                 gameContainer.innerHTML = '';
                 pegMap.clear();

                 createPegs();
                 createBoundaries();

                 Composite.allBodies(world).forEach(body => {
                     if (body.isStatic && (body.label === 'peg' || body.label === 'divider')) {
                         if (!body.domElement) {
                            createDOMElement(body);
                         } else {
                             syncDOM(body);
                         }
                     }
                 });
            }

            createPegs();
            createBoundaries();
            updateButtonStates();

            Events.on(runner, 'tick', (event) => {
                const currentTime = event.timestamp;

                for (let i = activeBalls.length - 1; i >= 0; i--) {
                    const ballBody = activeBalls[i];
                    if (!ballBody || ballBody.isRemoving || !world.bodies.includes(ballBody)) {
                        continue;
                    }

                    try {
                        syncDOM(ballBody);

                        ballBody.trailCounter = (ballBody.trailCounter || 0) + 1;
                         if (ballBody.trailCounter >= 2) {
                             ballBody.trailCounter = 0;
                             const particle = document.createElement('div');
                             particle.classList.add('trail-particle');
                             particle.style.left = `${ballBody.position.x - 2.5}px`;
                             particle.style.top = `${ballBody.position.y - 2.5}px`;
                             particle.style.background = ballBody.ballColor.color;
                             if (gameContainer && gameContainer.parentNode) {
                                gameContainer.appendChild(particle);
                                setTimeout(() => particle.remove(), 400);
                             }
                         }

                        if (ballBody.position.y > bucketTriggerY && !ballBody.isSleeping) {
                            const ballX = ballBody.position.x;
                            const speed = Vector.magnitude(ballBody.velocity);
                            const isSettling = speed < 0.1 && Math.abs(ballBody.velocity.y) < 0.05 && ballBody.position.y > (containerHeight - bucketHeight * 0.8);

                            if (isSettling) {
                                if (ballX >= 0 && ballX <= containerWidth) {
                                    const bucketIndex = Math.floor(ballX / bucketWidth);
                                    if (bucketIndex >= 0 && bucketIndex < numBuckets) {
                                        const scoreValue = bucketValues[bucketIndex];
                                        const bucketCenterX = (bucketIndex + 0.5) * bucketWidth;
                                        const bucketEffectY = containerHeight - bucketHeight * 0.3;

                                        triggerEndParticles(bucketCenterX, bucketEffectY, scoreValue);
                                        currentScore += scoreValue;
                                        scoreDisplay.textContent = `Score: ${currentScore.toLocaleString()}`;
                                        scoreDisplay.classList.add('score-update');
                                        setTimeout(() => scoreDisplay.classList.remove('score-update'), 300);
                                        showScorePopup(scoreValue, bucketCenterX, bucketEffectY);
                                        removeBall(ballBody);
                                    } else {
                                         showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                                         removeBall(ballBody);
                                    }
                                } else {
                                    showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                                    removeBall(ballBody);
                                }
                                ballBody.lastSlowTime = null;
                            }
                        } else if (ballBody.position.y > containerHeight + ballRadius * 5) {
                             showScorePopup("Lost", containerWidth / 2, containerHeight * 0.8);
                             removeBall(ballBody);
                             ballBody.lastSlowTime = null;
                        } else {
                             const speed = Vector.magnitude(ballBody.velocity);
                             const angularSpeed = Math.abs(ballBody.angularVelocity);
                             const isStuckCandidate = (speed < STUCK_SPEED_THRESHOLD && angularSpeed < ANGULAR_VELOCITY_THRESHOLD && ballBody.position.y < bucketTriggerY);
                             const isSleepingAboveBuckets = (ballBody.isSleeping && ballBody.position.y < bucketTriggerY);

                             if (isStuckCandidate || isSleepingAboveBuckets) {
                                if (ballBody.lastSlowTime === null) {
                                    ballBody.lastSlowTime = currentTime;
                                } else {
                                    if (currentTime - ballBody.lastSlowTime > STUCK_TIME_MS) {
                                        console.log(`Nudging potentially stuck/sleeping ball ${ballBody.id}`);
                                        Body.setSleeping(ballBody, false);

                                        const nudgeForceMagnitude = STUCK_NUDGE_FORCE * ballBody.mass;
                                        const nudge = {
                                            x: (Math.random() - 0.5) * 0.5 * nudgeForceMagnitude,
                                            y: (1.0 + Math.random() * 0.5) * nudgeForceMagnitude
                                        };

                                        Body.applyForce(ballBody, ballBody.position, nudge);
                                        ballBody.lastSlowTime = null;
                                    }
                                }
                             } else {
                                 ballBody.lastSlowTime = null;
                             }
                        }
                    } catch (e) {
                         console.error("Error processing ball in tick:", ballBody?.id, e);
                         removeBall(ballBody, true); 
                    }
                }
            });

            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    let pegBody = null;
                    let ballBodyA = null;
                    let ballBodyB = null;

                    if (pair.bodyA.label === 'ball') ballBodyA = pair.bodyA;
                    if (pair.bodyB.label === 'ball') ballBodyB = pair.bodyB;
                    if (pair.bodyA.label === 'peg') pegBody = pair.bodyA;
                    if (pair.bodyB.label === 'peg') pegBody = pair.bodyB;


                    if (pegBody && ballBodyA && activeBalls.includes(ballBodyA)) {
                        handlePegHit(pegBody);
                        ballBodyA.lastSlowTime = null;
                        if (ballBodyA.isSleeping) Body.setSleeping(ballBodyA, false);
                    }
                     if (pegBody && ballBodyB && activeBalls.includes(ballBodyB)) {
                        handlePegHit(pegBody);
                        ballBodyB.lastSlowTime = null;
                        if (ballBodyB.isSleeping) Body.setSleeping(ballBodyB, false);
                    }


                     if (ballBodyA && ballBodyB) {
                         if(activeBalls.includes(ballBodyA)) {
                            ballBodyA.lastSlowTime = null;
                            if (ballBodyA.isSleeping) Body.setSleeping(ballBodyA, false);
                         }
                         if(activeBalls.includes(ballBodyB)) {
                             ballBodyB.lastSlowTime = null;
                            if (ballBodyB.isSleeping) Body.setSleeping(ballBodyB, false);
                         }
                     }
                }
            });

            dropButton.addEventListener('click', () => {
                 initAudio();
                 if (dropSingleBall()) {
                     playDropSound();
                 }
            });

            dropMultipleButton.addEventListener('click', () => {
                 initAudio();
                 let droppedCount = 0;
                 const maxToDrop = Math.min(5, maxBalls - activeBallCount);
                 if (maxToDrop <= 0) return;

                 for (let i = 0; i < maxToDrop; i++) {
                     setTimeout(() => {
                         if(dropSingleBall()) {
                             if (droppedCount === 0) playDropSound();
                             droppedCount++;
                         }
                     }, i * 10); 
                 }
            });

            window.addEventListener('resize', handleResize);

            Runner.run(runner, engine);
            handleResize(); 
            setInterval(() => {
                const currentTime = engine.timing.timestamp;
                activeBalls.forEach(ballBody => {
                    if (ballBody.isRemoving || !world.bodies.includes(ballBody)) return;
                    const longStuckTime = STUCK_TIME_MS * 5;
                    const speed = Vector.magnitude(ballBody.velocity);
                    const angularSpeed = Math.abs(ballBody.angularVelocity);
                    if (ballBody.position.y < bucketTriggerY && (speed < 0.01 && angularSpeed < 0.01)) {
                         if (ballBody.lastVerySlowTime === null || ballBody.lastVerySlowTime === undefined) {
                             ballBody.lastVerySlowTime = currentTime;
                         } else {
                              if (currentTime - ballBody.lastVerySlowTime > longStuckTime) {
                                   console.warn(`Failsafe: Removing potentially permanently stuck ball ${ballBody.id}`);
                                   showScorePopup("Lost", ballBody.position.x, ballBody.position.y - 20);
                                   removeBall(ballBody, true); 
                              }
                         }
                    } else {
                         ballBody.lastVerySlowTime = null;
                    }
                });
            }, 2000); 


        });
    </script>
</body>
</html>
